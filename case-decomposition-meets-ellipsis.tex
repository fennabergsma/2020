% !TEX root = thesis.tex

\chapter{Case decomposition and ellipsis}

At the beginning of the previous chapter I showed that the case scale \tsc{nom < acc < dat} appears in headless relatives. In most accounts for headless relatives (\citealt[cf.][]{pittner1995,vogel2001,grosu2003,harbert1978}, an exception to this is \citealt{himmelreich2017}) the case scale is stipulated. Headless relatives simply obey to that hierarchy. \pgcitet{pittner1995}{201:fn.4} makes this explicit: ``One of the reviewers notes that an explanation in terms of a Case hierarchy is rather stipulative. However, as far as I know, nobody has suggested a nonstipulative explanation for these facts.''

What I showed as well in the previous chapter is the case scale \tsc{nom < acc < dat} is a wide-spread phenomenon: it recurs. The scale can be observed in at least two more syntactic phenomena: agreement en relativization.\footnote{
In this dissertation I do not work out accounts for these two syntactic phenomena. They merely serve as an illustration that the pattern is reflected in other syntactic phenomena as well.}
The case scale also appears within morphology in syncretism patterns and formal containment. \pgcitet{pittner1995}{201:fn.4} makes this link to morphology as well: ``Furthermore, the Case hierarchies receive some independent support by morphology as shown by the various inflectional paradigms.''

I am not after a theory in which the case hierarchy is not something construction specific, and syntax and morphology both have their own case hierarchy. I argue that there is a single trigger that is responsible for the case scale in different subparts of language \citep[cf.][on numeral constructions]{caha2019}. Specifically, I show that the observed case scale naturally follows on the assumption that the case hierarchy is deeply anchored in syntax. The case scale in morphology and syntax are merely reflexes of how case is organized in language.\footnote{
\citet{himmelreich2017} works this intuition out in a different way.
}

In this chapter I show that the case scale can be derived is case is decomposed. The precise facts in headless relatives relatives follow after adding an ellipsis that deletes phrases.


\section{Case decomposition}

The intuition: case is complex

containment:

\exg. luw -e:l -na\\
 3\tsc{sg}.\ac{nom} -\ac{acc} -\ac{dat}\\ \flushfill{Khanty, \pgcitealt{nikolaeva1999}{16}}

syncretism:

contigent zones, no ABA. spellout is not only exact match, but also a subset of the features can be a match

I show how this can be derived, within Nanosyntax, the framework in which I work this proposal out.



\subsection{The basic idea}

\citet{caha2009,caha2013} (followed by \citealt[cf.][]{starke2009,bobaljik2012,mcfadden2018,smith2019,vanbaal2018}) has extensively argued that case should be decomposed into privative features. Specifically, the decomposition is cumulative: each case has a different number of case features, and the number grows monotonically.
This is illustrated in Table \ref{tbl:case-decomposed}. Accusative has all the features that nominative has (here \tsc{f}1) plus one extra (here \tsc{f}2). Dative has all the features accusative has (\tsc{f} and \tsc{f}2) plus one extra (\tsc{f}3).

\begin{table}[ht]
  \center
	\caption {Case decomposed}
		\begin{tabular}{ll}
    \toprule
    case      & features                      \\
    \midrule
    \tsc{nom} & \tsc{f}1                      \\
    \tsc{acc} & \tsc{f}1, \tsc{f}2            \\
    \tsc{dat} & \tsc{f}1, \tsc{f}2, \tsc{f}3  \\
    \bottomrule
    \end{tabular}
    \label{tbl:case-decomposed}
\end{table}

The decomposition in Table \ref{tbl:case-decomposed} forms the basis to derive the case scale effects observed in the previous chapter. The next section shows how case containment and syncretism effects follow naturally. Later in this chapter I show how the decomposition also derives the case competition facts in headless relatives.

%should I talk about alternatives and why they do not work?


\subsection{Deriving syncretism}

In this section I show how case syncretism patterns can be derived from the case decomposition in Table \ref{tbl:case-decomposed}. I repeat an example that shows the possible and impossible syncretism patterns in Table \ref{tbl:syncretisms-derive}.

\begin{table}[ht]
  \center
  \caption {Syncretism pattern}
    \input{tables/syncretism-nom-acc-dat.tex}
  \label{tbl:syncretisms-derive}
\end{table}

The intuition is the following.

 % The morphological form of the pronouns mirror the cumulative feature decomposition given in Table \ref{tbl:case-decomposed}. That is, the accusative has the morphology that the nominative has (\tit{luw}) plus something extra (\tit{-e:l}). The dative has the morphology that the accusative has (\tit{luw-e:l}) plus something extra (\tit{luw-e:l}-na). In what follows I make it concrete how syntactic features translate to morphological form.


The proposal in this dissertation is worked out in Nanosyntax. I provide background assumptions on the framework whenever necessary to follow the discussion as I proceed. At this point I discuss the general architecture of Nanosyntax, its lexicon, phrasal spellout and matching between syntax and the lexicon.

The architecture of Nanosyntax is schematically shown in Figure \ref{fig:nano} \citep[from][]{vandenwyngaerd2020,caha2019}. In Nanosyntax, syntax starts with atomic features, and it builds complex syntactic trees. Specifically, there are no `feature bundles' that enter the syntax. The only way complex feature structures come to exist is a a result of merge.
After syntax (actually, each instance of merge), the syntactic structure is matched against the lexicon for pronunciation. The lexicon `translates' between syntactic representations on the one hand and phonology (PF) and concepts (CF) on the other hand. So, Nanosyntax is a late insertion model: (lexical) insertion takes place late, namely after syntax.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[node distance = 1cm, auto]
    \tikzstyle{block} = [rectangle, draw, text width=5em, text centered, rounded corners, minimum height=2em]
    \tikzstyle{line} = [draw, -latex']
      \node [block] (syntax) {Syntax};
      \node [block, below of=syntax, node distance=1.5cm] (lexicon) {Lexicon};
      \node [block, below left=0.5cm and -1cm of lexicon] (pf) {PF};
      \node [block, below right=0.5cm and -1cm of lexicon] (cf) {CF};
      \path [line] (syntax) -- (lexicon);
      \path [line] (lexicon) -- (pf);
      \path [line] (lexicon) -- (cf);
  \end{tikzpicture}
  \caption{Nanosyntactic model of grammar}
  \label{fig:nano}
\end{figure}

In Nanosyntax, the lexicon is nothing but links between syntactic representations, phonological representations and conceptual representations \citep{starke2014}.\footnote{
The syntactic representation does not have to correspond to both a phonological and a conceptual representation. Syntactic representation that only correspond to a conceptual representations and not to phonological representations are (phrasal or clausal) idioms. Syntactic representations that only correspond to phonological representations but not to conceptual representations are for instance irregular plurals.
}
%I leave out semantics here, because it's not so important for case here.
The fact that only syntax can create complex feature structures also has a consequence for the content of the lexicon.
Syntactic structures are constrained by certain principles, such that only well-formed syntactic structures exist. Since the lexical items from the lexicon link syntactic representation to phonological and conceptual representation, these syntactic representations are constrained by the same principles as syntactic trees are. As a result, the lexicon only contains well-formed syntactic structures. The lexicon does not contain unstructured `feature bundles', because they could never be created by syntax.

Following complex structures only be created with merge, a lexical entries as xxx do not exist. This cannot be the result of merge and syntax starts with atomic features.

\ex. [ \tsc{f}1, \tsc{f}2, \tsc{f}3 ]

instead, we have a tree

\ex. \begin{forest} boom
  [\ac{dat}P
      [\ac{f}3]
      [\ac{acc}P
          [\ac{f}2]
          [\ac{nom}P
              [\ac{f}1]
              ]
          ]
      ]
  ]
\end{forest}

phrasal spellout
multiple features with a single element

% A crucial part of this model is the idea that linking syntactically wellformed
% objects to phonology is not restricted to terminals. Since phrases
% containing multiple terminals are also well-formed syntactic objects, they
% may be easily pronounced by a single piece of phonology (a single morpheme
% in the traditional sense), provided these terminals form a constituent
% (i.e., they correspond to a syntactic object). An example is provided in (20)
% by the entry for an M-root. It will become clear in the course of the discussion
% that in our model, spellout in fact has to target phrasal nodes and
% cannot target terminals.



Let us apply this now to pronouns. I simplify. (1) I do not show internal complexity of pronouns, including person and number features. I just make a triangle.

For Faroese specific, (2) make Faroese pronouns monomorphemic

\ex.
\a.
\begin{forest} boom
  [\ac{nom}P
      [\ac{f}1]
      [NP
          [3\tsc{sg}, roof]
      ]
  ]
\end{forest}
\b.
\begin{forest} boom
  [\ac{acc}P
      [\ac{f}2]
      [\ac{nom}P
          [\ac{f}1]
          [3\ac{sg}
              [..., roof]
          ]
      ]
  ]
\end{forest}
\b.
\begin{forest} boom
  [\ac{dat}P
      [\ac{f}3]
      [\ac{acc}P
          [\ac{f}2]
          [\ac{nom}P
              [\ac{f}1]
              [3\ac{sg}
                  [..., roof]
              ]
          ]
      ]
  ]
\end{forest}

not only exact matching works


\ex. \tbf{The Superset Principle} \citet{starke2009}:\\
A lexically stored tree matches a syntactic node iff the lexically stored tree contains the syntactic node.

What the Superset Principle states is that matching between a lexical tree and a syntactic tree does not require full identity, but ‘only’ containment.

jullie: a single lexical entry for all

\ex.
\begin{forest} boom
  [\ac{dat}P
      [\ac{f}3]
      [\ac{acc}P
          [\ac{f}2]
          [\ac{nom}P
              [\ac{f}1]
              [2\ac{pl}
                  [..., roof]
              ]
          ]
      ]
  ]
\end{forest}

minimize junk

\ex. \tbf{The Elsewhere Condition} (\citealt{kiparsky1973}, formulated as in \citealt{caha2019}):\\
When two entries can spell out a given node, the more specific entry wins. Under the Superset Principle governed insertion, the more specific entry is the one which has fewer unused features.

sie for acc
ihr for dat

okkur for dat
vidxd for nom


no ABA



\subsection{Deriving case containment}

In this section I show how morphological case containment can be derived from the case decomposition in Table \ref{tbl:case-decomposed}. I repeat an example that shows morphological case containment in Table \ref{tbl:cont-khanty} \pgcitep{nikolaeva1999}{16}.

\begin{table}[ht]
  \center
  \caption {Containment in \tsc{3sg} in Khanty}
    \input{tables/containment-nom-acc-dat.tex}
  \label{tbl:cont-khanty-3sg}
\end{table}

The intuition is the following. The morphological form of the pronouns mirror the cumulative feature decomposition given in Table \ref{tbl:case-decomposed}. That is, the accusative has the morphology that the nominative has (\tit{luw}) plus something extra (\tit{-e:l}). The dative has the morphology that the accusative has (\tit{luw-e:l}) plus something extra (\tit{luw-e:l}-na). In what follows I make it concrete how syntactic features translate to morphological form.

first the nominative

\ex.
\begin{forest} boom
  [\ac{nom}P
      [\ac{nom}]
      [3\ac{sg}
          [.., roof]
      ]
  ]
  {\draw (.east) node[right]{⇔ \tit{luw}}; }
\end{forest}

\ex. \begin{forest} boom
[\tsc{nomP},name=nomp,
tikz={
\node[label=below right:\tit{luw},
draw,circle,
xscale=0.8,yscale=1,
fit=(nomp)(nom)(3sg)(np)]{};
}
    [\ac{nom},name=nom]
    [NP,name=np
        [\tsc{3sg},name=3sg, roof],baseline
    ]
]
\end{forest}

then the accusative

\ex. \begin{forest} boom
  [\ac{acc}P
      [\ac{acc}]
  ]
  {\draw (.east) node[right]{⇔ \tit{-e:l}}; }
\end{forest}

but movement

\ex. \begin{forest} boom
[\ac{acc}P,name=accp2, s sep=20mm
    [\tsc{nomP},name=nomp,
    tikz={
    \node[label=below right:\tit{luw},
    draw,circle,
    xscale=0.8,yscale=1,
    fit=(nomp)(nom)(3sg)(np)]{};
    }
        [\ac{nom},name=nom]
        [NP,name=np
            [\tsc{3sg},name=3sg, roof],baseline
        ]
    ]
    [\ac{acc}P,name=accp,
    tikz={
    \node[label={below right:\tit{-e:l}},
    draw,circle,
    xscale=0.7,yscale=0.9,
    fit=(acc)(accp)]{};
    }
     [\ac{acc},name=acc]
    ]
]
\end{forest}

then dative


\ex. \begin{forest} boom
  [\ac{dat}P
      [\ac{dat}]
  ]
  {\draw (.east) node[right]{⇔ \tit{-na}}; }
\end{forest}


\ex.
\begin{forest} boom
[\tsc{datP}
    [\ac{acc}P,name=accp2, s sep=20mm
        [\tsc{nomP},name=nomp,
        tikz={
        \node[label=below right:\tit{luw},
        draw,circle,
        xscale=0.8,yscale=1,
        fit=(nomp)(nom)(3sg)(np)]{};
        }
            [\ac{nom},name=nom]
            [NP,name=np
                [\tsc{3sg},name=3sg, roof],baseline
            ]
        ]
        [\ac{acc}P,name=accp,
        tikz={
        \node[label={below right:\tit{-e:l}},
        draw,circle,
        xscale=0.7,yscale=0.9,
        fit=(acc)(accp)]{};
        }
         [\ac{acc},name=acc]
        ]
    ]
    [\tsc{datP},name=datp,
    tikz={
    \node[label={below right:\tit{-na}},
    draw,circle,
    xscale=0.7,yscale=0.9,
    fit=(dat)(datp)]{};
    }
        [\ac{dat},name=dat]
    ]
]
\end{forest}






\section{Ellipsis}

Ellipsis targets phrases

it does not delete elements one by one

(1) Sluicing
Someone woke up early
but I have no idea who woke up early.

(2) VP ellipsis
John woke up early, and Mary did wake up early.

(3) Fragment answers
Q: Who woke up early?
A: John woke up early


(Õ) VP Ellipsis:
a. John was hassled by the police and Mary was [VP hassled by the police ] too.
b. John put his beer on the floor, so Mary did [VP put her beer on the floor ]


\section{Reflex of morphology in syntax}


\subsection{Morphology}

\ex.
\begin{forest} boom
  [\tsc{datP},name=datp,
  tikz={
  \node[draw,circle,LG,
  xscale=0.8,yscale=1,
  fill opacity=0.2,
  fill=LG,
  fit=(datp)(dat)(nom)(x)]{};
  }
      [\ac{dat},name=dat]
        [\ac{acc}P,name=accp,
        tikz={
        \node[draw,circle,
        xscale=0.75,yscale=0.95,
        fill opacity=0.2,
        fill=DG,DG,
        fit=(accp)(acc)(nom)(np)(x)]{};
        }
          [\ac{acc},name=acc]
          [\tsc{nomP},name=nomp
              [\ac{nom},name=nom]
              [NP,name=np
                  [...,name=x, roof]
              ]
          ]
      ]
  ]
\end{forest}


\ex.
\begin{forest} boom
  [\tsc{datP},name=datp,
  tikz={
  \node[draw,circle,LG,
  xscale=0.8,yscale=1,
  fill opacity=0.2,
  fill=LG,
  fit=(datp)(dat)(nom)(x)]{};
  }
      [\ac{dat},name=dat]
      [\ac{acc}P,name=accp
          [\ac{acc},name=acc]
          [\tsc{nomP},name=nomp,
          tikz={
          \node[draw,circle,DG,
          xscale=0.7,yscale=0.9,
          fill opacity=0.2,
          fill=DG,
          fit=(nomp)(nom)(np)(x)]{};
          }
              [\ac{nom},name=nom]
              [NP,name=np
                  [...,name=x, roof]
              ]
          ]
      ]
  ]
\end{forest}



\ex.
\begin{forest} boom
      [\ac{acc}P,name=accp,
      tikz={
      \node[draw,circle,
      xscale=0.8,yscale=1,
      fill opacity=0.2,
      fill=LG,LG,
      fit=(accp)(acc)(nom)(x)]{};
      }
          [\ac{acc},name=acc]
          [\tsc{nomP},name=nomp,
          tikz={
          \node[draw,circle,DG,
          xscale=0.75,yscale=0.95,
          fill opacity=0.2,
          fill=DG,
          fit=(nomp)(nom)(x)]{};
          }
              [\ac{nom},name=nom]
              [NP,name=np
                  [...,name=x, roof]
              ]
          ]
      ]
  ]
\end{forest}



\subsection{Syntax}

\begin{table}[H]
  \center
	\caption {\ac{dat}P deletes \ac{acc}P}
		\begin{tabular}[b]{c c}
      \begin{forest} boom
        [\tsc{datP}
            [\ac{dat}]
              [\ac{acc}P,name=accp,
              tikz={
              \node[draw,circle,
              xscale=0.775,yscale=0.975,
              fit=(accp)(acc)(nom)(x)]{};
              }
                [\ac{acc},name=acc]
                [\tsc{nomP},name=nomp
                    [\ac{nom},name=nom]
                    [NP,name=np
                        [...,name=x, roof ,baseline]
                    ]
                ]
            ]
        ]
      \end{forest}
      &
      \begin{forest} boom
        [\textcolor{LG}{\tsc{accP}},name=accp,
        tikz={
        \node[draw,circle,
        xscale=0.775,yscale=0.975,
        fit=(accp)(acc)(nom)(x)]{};
        }
            [\textcolor{LG}{\ac{acc}},name=acc,edge=LG]
            [\textcolor{LG}{\tsc{nomP}},name=nomp,edge=LG
                [\textcolor{LG}{\ac{nom}},name=nom,edge=LG]
                [\textcolor{LG}{NP},name=np,edge=LG
                    [\textcolor{LG}{...},name=x,
                    roof, baseline, edge=LG
                    ]
                ]
            ]
        ]
      \end{forest} \\
  \end{tabular}
\end{table}

\begin{table}[H]
  \center
	\caption {\ac{dat}P deletes \ac{nom}P}
		\begin{tabular}[b]{cc}
      \begin{forest} boom
        [\tsc{datP}
            [\ac{dat}]
              [\ac{acc}P,name=accp
                [\ac{acc},name=acc]
                [\tsc{nomP},name=nomp,
                tikz={
                \node[draw,circle,
                xscale=0.75,yscale=0.95,
                fit=(nomp)(nom)(x)]{};
                }
                    [\ac{nom},name=nom]
                    [NP,name=np
                        [...,name=x, roof, baseline]
                    ]
                ]
            ]
        ]
      \end{forest}
      &
      \begin{forest} boom
        [\textcolor{LG}{\tsc{nomP}},name=nomp,
        tikz={
        \node[draw,circle,
        xscale=0.75,yscale=0.95,
        fit=(nomp)(nom)(x)]{};
        }
            [\textcolor{LG}{\ac{nom}},name=nom,edge=LG]
            [\textcolor{LG}{NP},name=np,baseline,edge=LG
                [\textcolor{LG}{...},name=x,
                roof,baseline,edge=LG
                ]
            ]
        ]
      \end{forest} \\
  \end{tabular}
\end{table}

\begin{table}[H]
  \center
	\caption {\ac{acc}P deletes \ac{nom}P}
		\begin{tabular}[b]{cc}
      \begin{forest} boom
          [\ac{acc}P,name=accp
              [\ac{acc},name=acc]
              [\tsc{nomP},name=nomp,
              tikz={
              \node[draw,circle,
              xscale=0.75,yscale=0.95,
              fit=(nomp)(nom)(x)]{};
              }
                  [\ac{nom},name=nom]
                  [NP,name=np
                      [...,name=x,
                      roof,baseline
                      ]
                  ]
              ]
          ]
      \end{forest}
      &
      \begin{forest} boom
        [\textcolor{LG}{\tsc{nomP}},name=nomp,
        tikz={
        \node[draw,circle,
        xscale=0.75,yscale=0.95,
        fit=(nomp)(nom)(x)]{};
        }
            [\textcolor{LG}{\ac{nom}},name=nom,
            edge=LG]
            [\textcolor{LG}{NP},name=np,
            edge=LG
                [\textcolor{LG}{...},name=x,
                roof,baseline,edge=LG
                ]
            ]
        ]
      \end{forest}\\
  \end{tabular}
\end{table}
