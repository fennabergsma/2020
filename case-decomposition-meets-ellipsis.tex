% !TEX root = thesis.tex

\chapter{Case decomposition meets ellipsis}

At the beginning of the previous chapter I showed that the case scale \tsc{nom < acc < dat} appears in headless. In most accounts for headless relatives (\citealt[cf.][]{pittner1995,vogel2001,grosu2003,harbert1978}, an exception to this is \citealt{himmelreich2017}) the case scale is stipulated. Headless relatives simply obey to that hierarchy. \pgcitet{pittner1995}{201:fn.4} notes: ``One of the reviewers notes that an explanation in terms of a Case hierarchy is rather stipulative. However, as far as I know, nobody has suggested a nonstipulative explanation for these facts.''

What I showed as well in the previous chapter is the case scale \tsc{nom < acc < dat} is a wide-spread phenomenon: it recurs. The scale can be observed in at least two more syntactic phenomena: agreement en relativization.\footnote{
In this dissertation I do not work out accounts for these two syntactic phenomena. They merely serve as an illustration that the pattern is reflected in other syntactic phenomena as well.}
The case scale also appears within morphology in syncretism patterns and formal containment. \pgcitet{pittner1995}{201:fn.4} mentioned the role of morphology: ``Furthermore, the Case hierarchies receive some independent support by morphology as shown by the various inflectional paradigms.''

The question arises what the nature of this case hierarchy is. Are there multiple hierarchies active in different subparts of language (i.e. syntax and morphology)? Or is there a single hierarchy that is made reference to from different the subparts of syntax and morphology? And how are syntax and morphology then connected? I argue that there is a single trigger that is responsible for the case scale in different subparts of language \citep[cf.]{caha2019}.\footnote{
This intuition has been worked out in a different way in \posscitet{himmelreich2017} dissertation.
} Specifically, I show that the case scale naturally follows assuming that the case hierarchy is deeply anchored in syntax. The case scale in morphology and syntax are merely reflexes of how case is organized in language.

In this chapter I show that the case scale can be derived is case is decomposed. The precise facts in headless relatives relatives follow after adding an ellipsis that deletes phrases.


\section{Case decomposition}

The intuition: case is complex

containment:

\exg. luw -e:l -na\\
 3\tsc{sg}.\ac{nom} -\ac{acc} -\ac{dat}\\ \flushfill{Khanty, \pgcitealt{nikolaeva1999}{16}}

syncretism:

contigent zones, no ABA. spellout is not only exact match, but also a subset of the features can be a match

I show how this can be derived, within Nanosyntax, the framework in which I work this proposal out.



\subsection{The basic idea}

\citet{caha2009,caha2013} (followed by \citealt[cf.][]{starke2009,bobaljik2012,mcfadden2018,smith2019,vanbaal2018}) has extensively argued that case should be decomposed into privative features. Specifically, the decomposition is cumulative: each case has a different number of case features, and the number grows monotonically.
This is illustrated in Table \ref{tbl:case-decomposed}. Accusative has all the features that nominative has (here \tsc{f}1) plus one extra (here \tsc{f}2). Dative has all the features accusative has (\tsc{f} and \tsc{f}2) plus one extra (\tsc{f}3).

\begin{table}[ht]
  \center
	\caption {Case decomposed}
		\begin{tabular}{ll}
    \toprule
    case      & features                      \\
    \midrule
    \tsc{nom} & \tsc{f}1                      \\
    \tsc{acc} & \tsc{f}1, \tsc{f}2            \\
    \tsc{dat} & \tsc{f}1, \tsc{f}2, \tsc{f}3  \\
    \bottomrule
    \end{tabular}
    \label{tbl:case-decomposed}
\end{table}

The decomposition in Table \ref{tbl:case-decomposed} forms the basis to derive the case scale effects observed in the previous chapter. The next section shows how case containment and syncretism effects follow naturally. Later in this chapter I show how the decomposition also derives the case competition facts in headless relatives.

%should I talk about alternatives and why they do not work?

\subsection{Deriving case containment}

In this section I show how morphological case containment can be derived from the case decomposition in Table \ref{tbl:case-decomposed}. I repeat an example that shows morphological case containment in Table \ref{tbl:cont-khanty} \pgcitep{nikolaeva1999}{16}.

\begin{table}[ht]
  \center
  \caption {Containment in \tsc{3sg} in Khanty}
    \input{tables/containment-nom-acc-dat.tex}
  \label{tbl:cont-khanty-3sg}
\end{table}

The intuition is the following. The morphological form of the pronouns mirror the cumulative feature decomposition given in Table \ref{tbl:case-decomposed}. That is, the accusative has the morphology that the nominative has (\tit{luw}) plus something extra (\tit{-e:l}). The dative has the morphology that the accusative has (\tit{luw-e:l}) plus something extra (\tit{luw-e:l}-na). In what follows I make it concrete how syntactic features translate to morphological form.

I work the proposal in this dissertation out in Nanosyntax. I provide background assumptions on the framework wherever necessary to follow the discussion as I proceed. At this point I discuss the general architecture of Nanosyntax and its lexicon.

The architecture of Nanosyntax is schematically shown in Figure \ref{fig:nano} \citep[from][]{vandenwyngaerd2020,caha2019}. In Nanosyntax, syntax starts with atomic features, and it builds complex syntactic trees. Specifically, there are no `feature bundles' that enter the syntax. The only way complex feature structures come to exist is a a result of merge.
After syntax (more specifically, each instance of merge), the syntactic structure is matched against the lexicon for pronunciation. The lexicon `translates' between syntactic representations on the one hand and phonology (PF) and concepts (CF) on the other hand. So, Nanosyntax is a late insertion model: syntax happens before (lexical) insertion takes place.

\begin{figure}[ht]
  \centering
  \begin{tikzpicture}[node distance = 1cm, auto]
    \tikzstyle{block} = [rectangle, draw, text width=5em, text centered, rounded corners, minimum height=2em]
    \tikzstyle{line} = [draw, -latex']
      \node [block] (syntax) {Syntax};
      \node [block, below of=syntax, node distance=1.5cm] (lexicon) {Lexicon};
      \node [block, below left=0.5cm and -1cm of lexicon] (pf) {PF};
      \node [block, below right=0.5cm and -1cm of lexicon] (cf) {CF};
      \path [line] (syntax) -- (lexicon);
      \path [line] (lexicon) -- (pf);
      \path [line] (lexicon) -- (cf);
  \end{tikzpicture}
  \caption{Nanosyntactic model of grammar}
  \label{fig:nano}
\end{figure}

Now we turn to what the lexicon looks like in Nanosyntax.

In the lexicon there are lexical entries.


what's in the lexion?

Following Starke (2014), I understand lexical entries as nothing else but links
between well-formed syntactic representations, well formed phonological representations,
and/or conceptual representations. One of the motivations for adopting
this view is to have a ‘principled’ theory of the lexicon. What ‘principled’
means is not that lexical items are no longer arbitrary associations between syntax,
phonology and/or conceptual meaning; they still are. Rather, ‘principled’
is used in the sense that the format of the lexical item is restricted. Since wellformed
syntactic structures are constrained by principles, and lexical items link
such representations to their pronunciation (a phonological representation), it
follows that the representations in a lexical entry are constrained by universal
principles (the same ones that regulate what syntactic trees look like).





case trees

\ex.
\a.
\begin{forest} boom
  [\ac{nom}P
      [\ac{f}1]
      [NP
          [..., roof]
      ]
  ]
\end{forest}
\b.
\begin{forest} boom
  [\ac{acc}P
      [\ac{f}2]
      [\ac{nom}P
          [\ac{f}1]
          [NP
              [..., roof]
          ]
      ]
  ]
\end{forest}
\b.
\begin{forest} boom
  [\ac{dat}P
      [\ac{f}3]
      [\ac{acc}P
          [\ac{f}2]
          [\ac{nom}P
              [\ac{f}1]
              [NP
                  [..., roof]
              ]
          ]
      ]
  ]
\end{forest}

now let's look at the case decomposition example again

\begin{table}[ht]
  \center
  \caption {Containment pattern}
    \input{tables/containment-nom-acc-dat.tex}
  \label{tbl:containment-derive}
\end{table}

first the nominative
\footnote{
I address the issue of phrasal spellout in the next section.
}

\ex.
\begin{forest} boom
  [\ac{nom}P
      [\ac{nom}]
      [NP
          [\tsc{3sg}, roof]
      ]
  ]
  {\draw (.east) node[right]{⇔ \tit{luw}}; }
\end{forest}

\ex. \begin{forest} boom
[\tsc{nomP},name=nomp,
tikz={
\node[label=below right:\tit{luw},
draw,circle,
xscale=0.8,yscale=1,
fit=(nomp)(nom)(3sg)(np)]{};
}
    [\ac{nom},name=nom]
    [NP,name=np
        [\tsc{3sg},name=3sg, roof],baseline
    ]
]
\end{forest}

then the accusative
\footnote{
I will come back to the movement later.
}

\ex. \begin{forest} boom
  [\ac{acc}P
      [\ac{acc}]
  ]
  {\draw (.east) node[right]{⇔ \tit{-e:l}}; }
\end{forest}

\ex. \begin{forest} boom
[\ac{acc}P,name=accp2, s sep=20mm
    [\tsc{nomP},name=nomp,
    tikz={
    \node[label=below right:\tit{luw},
    draw,circle,
    xscale=0.8,yscale=1,
    fit=(nomp)(nom)(3sg)(np)]{};
    }
        [\ac{nom},name=nom]
        [NP,name=np
            [\tsc{3sg},name=3sg, roof],baseline
        ]
    ]
    [\ac{acc}P,name=accp,
    tikz={
    \node[label={below right:\tit{-e:l}},
    draw,circle,
    xscale=0.7,yscale=0.9,
    fit=(acc)(accp)]{};
    }
     [\ac{acc},name=acc]
    ]
]
\end{forest}

then dative


\ex. \begin{forest} boom
  [\ac{dat}P
      [\ac{dat}]
  ]
  {\draw (.east) node[right]{⇔ \tit{-na}}; }
\end{forest}


\ex.
\begin{forest} boom
[\tsc{datP}
    [\ac{acc}P,name=accp2, s sep=20mm
        [\tsc{nomP},name=nomp,
        tikz={
        \node[label=below right:\tit{luw},
        draw,circle,
        xscale=0.8,yscale=1,
        fit=(nomp)(nom)(3sg)(np)]{};
        }
            [\ac{nom},name=nom]
            [NP,name=np
                [\tsc{3sg},name=3sg, roof],baseline
            ]
        ]
        [\ac{acc}P,name=accp,
        tikz={
        \node[label={below right:\tit{-e:l}},
        draw,circle,
        xscale=0.7,yscale=0.9,
        fit=(acc)(accp)]{};
        }
         [\ac{acc},name=acc]
        ]
    ]
    [\tsc{datP},name=datp,
    tikz={
    \node[label={below right:\tit{-na}},
    draw,circle,
    xscale=0.7,yscale=0.9,
    fit=(dat)(datp)]{};
    }
        [\ac{dat},name=dat]
    ]
]
\end{forest}



\subsection{Deriving syncretism}

basic background on matching in nano

phrasal spellout
multiple features with a single element

faroese all different




\ex. \tbf{The Superset Principle} \citet{starke2009}:\\
A lexically stored tree matches a syntactic node iff the lexically stored tree contains the syntactic node.

What the Superset Principle states is that matching between a lexical tree and a syntactic tree does not require full identity, but ‘only’ containment.

\begin{table}[ht]
  \center
  \caption {Syncretism pattern}
    \input{tables/syncretism-nom-acc-dat.tex}
  \label{tbl:syncretisms-derive}
\end{table}

jullie: a single lexical entry for all

\ex. \tbf{The Elsewhere Condition} (\citealt{kiparsky1973}, formulated as in \citealt{caha2019}):\\
When two entries can spell out a given node, the more specific entry wins. Under the Superset Principle governed insertion, the more specific entry is the one which has fewer unused features.

sie for acc
ihr for dat

okkur for dat
vidxd for nom



\section{Ellipsis}

Ellipsis targets phrases

it does not delete elements one by one

(1) Sluicing
Someone stayed out until 7am,
but I have no idea who stayed out until 7 am.

(2) VP ellipsis
Elin stayed out until 7am, and Fraser did stay out until 7 am too.

(3) Fragment answers
Q: Who stayed out until 7am?
A: Elin stayed out until 7am


(Õ) VP Ellipsis:
a. Betsy was hassled by the police and Peter was [VP hassled by the police ] too.
b. John put his beer on the floor, so Mary did [VP put her beer on the floor ]


\section{Reflex of morphology in syntax}


\subsection{Morphology}

\ex.
\begin{forest} boom
  [\tsc{datP},name=datp,
  tikz={
  \node[draw,circle,LG,
  xscale=0.8,yscale=1,
  fill opacity=0.2,
  fill=LG,
  fit=(datp)(dat)(nom)(x)]{};
  }
      [\ac{dat},name=dat]
        [\ac{acc}P,name=accp,
        tikz={
        \node[draw,circle,
        xscale=0.75,yscale=0.95,
        fill opacity=0.2,
        fill=DG,DG,
        fit=(accp)(acc)(nom)(np)(x)]{};
        }
          [\ac{acc},name=acc]
          [\tsc{nomP},name=nomp
              [\ac{nom},name=nom]
              [NP,name=np
                  [...,name=x, roof]
              ]
          ]
      ]
  ]
\end{forest}


\ex.
\begin{forest} boom
  [\tsc{datP},name=datp,
  tikz={
  \node[draw,circle,LG,
  xscale=0.8,yscale=1,
  fill opacity=0.2,
  fill=LG,
  fit=(datp)(dat)(nom)(x)]{};
  }
      [\ac{dat},name=dat]
      [\ac{acc}P,name=accp
          [\ac{acc},name=acc]
          [\tsc{nomP},name=nomp,
          tikz={
          \node[draw,circle,DG,
          xscale=0.7,yscale=0.9,
          fill opacity=0.2,
          fill=DG,
          fit=(nomp)(nom)(np)(x)]{};
          }
              [\ac{nom},name=nom]
              [NP,name=np
                  [...,name=x, roof]
              ]
          ]
      ]
  ]
\end{forest}



\ex.
\begin{forest} boom
      [\ac{acc}P,name=accp,
      tikz={
      \node[draw,circle,
      xscale=0.8,yscale=1,
      fill opacity=0.2,
      fill=LG,LG,
      fit=(accp)(acc)(nom)(x)]{};
      }
          [\ac{acc},name=acc]
          [\tsc{nomP},name=nomp,
          tikz={
          \node[draw,circle,DG,
          xscale=0.75,yscale=0.95,
          fill opacity=0.2,
          fill=DG,
          fit=(nomp)(nom)(x)]{};
          }
              [\ac{nom},name=nom]
              [NP,name=np
                  [...,name=x, roof]
              ]
          ]
      ]
  ]
\end{forest}



\subsection{Syntax}

\begin{table}[H]
  \center
	\caption {\ac{dat}P deletes \ac{acc}P}
		\begin{tabular}[b]{c c}
      \begin{forest} boom
        [\tsc{datP}
            [\ac{dat}]
              [\ac{acc}P,name=accp,
              tikz={
              \node[draw,circle,
              xscale=0.775,yscale=0.975,
              fit=(accp)(acc)(nom)(x)]{};
              }
                [\ac{acc},name=acc]
                [\tsc{nomP},name=nomp
                    [\ac{nom},name=nom]
                    [NP,name=np
                        [...,name=x, roof ,baseline]
                    ]
                ]
            ]
        ]
      \end{forest}
      &
      \begin{forest} boom
        [\textcolor{LG}{\tsc{accP}},name=accp,
        tikz={
        \node[draw,circle,
        xscale=0.775,yscale=0.975,
        fit=(accp)(acc)(nom)(x)]{};
        }
            [\textcolor{LG}{\ac{acc}},name=acc,edge=LG]
            [\textcolor{LG}{\tsc{nomP}},name=nomp,edge=LG
                [\textcolor{LG}{\ac{nom}},name=nom,edge=LG]
                [\textcolor{LG}{NP},name=np,edge=LG
                    [\textcolor{LG}{...},name=x,
                    roof, baseline, edge=LG
                    ]
                ]
            ]
        ]
      \end{forest} \\
  \end{tabular}
\end{table}

\begin{table}[H]
  \center
	\caption {\ac{dat}P deletes \ac{nom}P}
		\begin{tabular}[b]{cc}
      \begin{forest} boom
        [\tsc{datP}
            [\ac{dat}]
              [\ac{acc}P,name=accp
                [\ac{acc},name=acc]
                [\tsc{nomP},name=nomp,
                tikz={
                \node[draw,circle,
                xscale=0.75,yscale=0.95,
                fit=(nomp)(nom)(x)]{};
                }
                    [\ac{nom},name=nom]
                    [NP,name=np
                        [...,name=x, roof, baseline]
                    ]
                ]
            ]
        ]
      \end{forest}
      &
      \begin{forest} boom
        [\textcolor{LG}{\tsc{nomP}},name=nomp,
        tikz={
        \node[draw,circle,
        xscale=0.75,yscale=0.95,
        fit=(nomp)(nom)(x)]{};
        }
            [\textcolor{LG}{\ac{nom}},name=nom,edge=LG]
            [\textcolor{LG}{NP},name=np,baseline,edge=LG
                [\textcolor{LG}{...},name=x,
                roof,baseline,edge=LG
                ]
            ]
        ]
      \end{forest} \\
  \end{tabular}
\end{table}

\begin{table}[H]
  \center
	\caption {\ac{acc}P deletes \ac{nom}P}
		\begin{tabular}[b]{cc}
      \begin{forest} boom
          [\ac{acc}P,name=accp
              [\ac{acc},name=acc]
              [\tsc{nomP},name=nomp,
              tikz={
              \node[draw,circle,
              xscale=0.75,yscale=0.95,
              fit=(nomp)(nom)(x)]{};
              }
                  [\ac{nom},name=nom]
                  [NP,name=np
                      [...,name=x,
                      roof,baseline
                      ]
                  ]
              ]
          ]
      \end{forest}
      &
      \begin{forest} boom
        [\textcolor{LG}{\tsc{nomP}},name=nomp,
        tikz={
        \node[draw,circle,
        xscale=0.75,yscale=0.95,
        fit=(nomp)(nom)(x)]{};
        }
            [\textcolor{LG}{\ac{nom}},name=nom,
            edge=LG]
            [\textcolor{LG}{NP},name=np,
            edge=LG
                [\textcolor{LG}{...},name=x,
                roof,baseline,edge=LG
                ]
            ]
        ]
      \end{forest}\\
  \end{tabular}
\end{table}





\section{Similar analyses}

Himmelreich
